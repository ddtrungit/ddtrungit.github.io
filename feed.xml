<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <title>TRUNG DUONG</title>
    <link href="http://blog.dtrungit.ga/feed.xml" rel="self" />
    <link href="http://blog.dtrungit.ga" />
    <updated>2022-06-15T15:29:31+07:00</updated>
    <author>
        <name>Duong Dinh Trung</name>
    </author>
    <id>http://blog.dtrungit.ga</id>

    <entry>
        <title>[Kubernetes] Hướng dẫn cài đặt Kubernetes với Kubeadmin</title>
        <author>
            <name>Duong Dinh Trung</name>
        </author>
        <link href="http://blog.dtrungit.ga/kubernetes-huong-dan-cai-dat-kubernetes-voi-kubeadmin/index.html"/>
        <id>http://blog.dtrungit.ga/kubernetes-huong-dan-cai-dat-kubernetes-voi-kubeadmin/index.html</id>
            <category term="Linux"/>
            <category term="K8s"/>

        <updated>2022-06-15T15:29:31+07:00</updated>
            <summary>
                <![CDATA[
                        <img src="http://blog.dtrungit.ga/media/posts/128/k8s.png" alt="" />
                    Phần 1. Chuẩn bị Quy hoạch Mô hình Phần 2. Chuẩn bị môi trường Bước 1: Đặt hostname cho từng&hellip;
                ]]>
            </summary>
        <content type="html">
            <![CDATA[
                    <img src="http://blog.dtrungit.ga/media/posts/128/k8s.png" alt="" />
                <h2>Phần 1. Chuẩn bị</h2>
<h3><a href="https://github.com/lacoski/kubernetes-note/blob/main/docs/setup/install-k8s-centos7-kubeadm.md#quy-ho%E1%BA%A1ch"></a>Quy hoạch</h3>
<figure class="wp-block-image size-large"><figure class="wp-image-522"><img loading="lazy"  src="https://blog.devopsviet.com/wp-content/uploads/2021/08/pic1-9-1024x222.png" data-is-external-image="true"  sizes="(max-width: 1024px) 100vw, 1024px" srcset="https://blog.devopsviet.com/wp-content/uploads/2021/08/pic1-9-1024x222.png 1024w, https://blog.devopsviet.com/wp-content/uploads/2021/08/pic1-9-300x65.png 300w, https://blog.devopsviet.com/wp-content/uploads/2021/08/pic1-9-768x167.png 768w, https://blog.devopsviet.com/wp-content/uploads/2021/08/pic1-9-1536x333.png 1536w, https://blog.devopsviet.com/wp-content/uploads/2021/08/pic1-9-816x177.png 816w, https://blog.devopsviet.com/wp-content/uploads/2021/08/pic1-9.png 1539w" alt="" width="1024" height="222" loading="lazy"></figure></figure>
<h2>Mô hình</h2>
<figure class="wp-block-image size-full"><figure class="wp-image-523"><img loading="lazy"  src="https://blog.devopsviet.com/wp-content/uploads/2021/08/pic2-6.png" data-is-external-image="true"  sizes="(max-width: 1016px) 100vw, 1016px" srcset="https://blog.devopsviet.com/wp-content/uploads/2021/08/pic2-6.png 1016w, https://blog.devopsviet.com/wp-content/uploads/2021/08/pic2-6-300x230.png 300w, https://blog.devopsviet.com/wp-content/uploads/2021/08/pic2-6-768x588.png 768w, https://blog.devopsviet.com/wp-content/uploads/2021/08/pic2-6-816x625.png 816w" alt="" width="1016" height="778" loading="lazy"></figure></figure>
<h2>Phần 2. Chuẩn bị môi trường</h2>
<h3><a href="https://github.com/lacoski/kubernetes-note/blob/main/docs/setup/install-k8s-centos7-kubeadm.md#b%C6%B0%E1%BB%9Bc-1-%C4%91%E1%BA%B7t-hostname-cho-t%E1%BB%ABng-node"></a>Bước 1: Đặt hostname cho từng node</h3>
<blockquote class="wp-block-quote">
<p>Thực hiện trên node Master 1181</p>
</blockquote>
<pre class="wp-block-code"><code>hostnamectl set-hostname master1181
</code></pre>
<blockquote class="wp-block-quote">
<p>Thực hiện trên node Worker 1182</p>
</blockquote>
<pre class="wp-block-code"><code>hostnamectl set-hostname worker1182
</code></pre>
<blockquote class="wp-block-quote">
<p>Thực hiện trên node Worker 1183</p>
</blockquote>
<pre class="wp-block-code"><code>hostnamectl set-hostname worker1183
</code></pre>
<h3><a href="https://github.com/lacoski/kubernetes-note/blob/main/docs/setup/install-k8s-centos7-kubeadm.md#b%C6%B0%E1%BB%9Bc-2-chu%E1%BA%A9n-b%E1%BB%8B-m%C3%B4i-tr%C6%B0%E1%BB%9Dng-tri%E1%BB%83n-khai"></a>Bước 2: Chuẩn bị môi trường triển khai</h3>
<blockquote class="wp-block-quote">
<p>Thực hiện trên tất cả các node</p>
</blockquote>
<p>Tắt SELinux, Firewall</p>
<pre class="wp-block-code"><code>sed -i 's/SELINUX=enforcing/SELINUX=disabled/g' /etc/sysconfig/selinux
sed -i 's/SELINUX=enforcing/SELINUX=disabled/g' /etc/selinux/config
systemctl stop firewalld
systemctl disable firewalld
</code></pre>
<p>Cấu hình đồng bộ thời gian</p>
<pre class="wp-block-code"><code>timedatectl set-timezone Asia/Ho_Chi_Minh

yum -y install chrony
systemctl enable chronyd.service
systemctl restart chronyd.service
chronyc sources
</code></pre>
<p>Disable swap</p>
<pre class="wp-block-code"><code>sudo sed -i '/swap/d' /etc/fstab
sudo swapoff -a
</code></pre>
<p>Cài đặt môi trường Docker</p>
<pre class="wp-block-code"><code>curl -fsSL https://get.docker.com/ | sh
sudo systemctl start docker
sudo systemctl status docker
sudo systemctl enable docker
</code></pre>
<p>Bổ sung cấu hình net filter</p>
<pre class="wp-block-code"><code>sudo modprobe br_netfilter
cat &lt;&lt;EOF | sudo tee /etc/sysctl.d/k8s.conf
net.bridge.bridge-nf-call-ip6tables = 1
net.bridge.bridge-nf-call-iptables = 1
EOF
sudo sysctl --system
</code></pre>
<p>Cấu hình file host</p>
<pre class="wp-block-code"><code>echo "
10.10.11.81 master1181
10.10.11.82 worker1182
10.10.11.83 worker1183" &gt;&gt; /etc/hosts
</code></pre>
<p>Khởi động lại (Tại bước này nên snapshot lại)</p>
<pre class="wp-block-code"><code>init 6
</code></pre>
<h2>Phần 3. Khởi tạo Cluster Kubernetes</h2>
<h3><a href="https://github.com/lacoski/kubernetes-note/blob/main/docs/setup/install-k8s-centos7-kubeadm.md#b%C6%B0%E1%BB%9Bc-1-c%C3%A0i-%C4%91%E1%BA%B7t-c%C3%A1c-g%C3%B3i-c%E1%BA%A7n-thi%E1%BA%BFt"></a>Bước 1: Cài đặt các gói cần thiết</h3>
<blockquote class="wp-block-quote">
<p>Thực hiện trên tất cả các node</p>
</blockquote>
<p>Thiết lập repo k8s</p>
<pre class="wp-block-code"><code>cat &lt;&lt;EOF | sudo tee /etc/yum.repos.d/kubernetes.repo
</code></pre>
<p>[kubernetes]</p>
<p>name=Kubernetes baseurl=https://packages.cloud.google.com/yum/repos/kubernetes-el7-\$basearch enabled=1 gpgcheck=1 repo_gpgcheck=1 gpgkey=https://packages.cloud.google.com/yum/doc/yum-key.gpg https://packages.cloud.google.com/yum/doc/rpm-package-key.gpg exclude=kubelet kubeadm kubectl EOF</p>
<p>Cài đặt kubelet kubeadm kubectl</p>
<p>Lưu ý:</p>
<ul>
<li>docker: để làm môi trường chạy các container.</li>
<li>kubeadm: Công cụ khởi tạo Cluster k8s.</li>
<li>kubelet: Thành phần chạy trên các host, có nhiệm vụ kích hoạt các pod và container trong cụm Cluser của K8S.</li>
<li>kubectl: Công cụ CLI (Giao diện dòng lệnh) để tương tác với K8s.</li>
</ul>
<pre class="wp-block-code"><code>sudo yum install -y kubelet kubeadm kubectl --disableexcludes=kubernetes
sudo systemctl enable --now kubelet</code></pre>
<p> </p>
<h3>Bước 2: Khởi tạo Cluster</h3>
<blockquote class="wp-block-quote">
<p>Thực hiện trên node master</p>
</blockquote>
<p>Khởi tạo Cluster</p>
<pre class="wp-block-code"><code>sudo kubeadm init --apiserver-advertise-address 10.10.11.81 --pod-network-cidr=10.244.0.0/16
</code></pre>
<p>Lưu ý:</p>
<ul>
<li><code>--apiserver-advertise-address</code>: Địa chỉ của node Master</li>
<li><code>--pod-network-cidr</code>: Dải địa chỉ sử dụng, phụ thuộc vào công nghệ sử dụng, trong bài sử dụng công nghệ network <code>flannel</code> nên giá trị bằng <code>10.244.0.0/16</code></li>
</ul>
<p>Kết quả</p>
<pre class="wp-block-code"><code>[root@master1181 ~]# sudo kubeadm init --apiserver-advertise-address 10.10.11.81 --pod-network-cidr=10.244.0.0/16
W1015 19:19:17.662622    1680 configset.go:348] WARNING: kubeadm cannot validate component configs for API groups [kubelet.config.k8s.io kubeproxy.config.k8s.io]
[init] Using Kubernetes version: v1.19.3
[preflight] Running pre-flight checks
	[WARNING IsDockerSystemdCheck]: detected "cgroupfs" as the Docker cgroup driver. The recommended driver is "systemd". Please follow the guide at https://kubernetes.io/docs/setup/cri/
[preflight] Pulling images required for setting up a Kubernetes cluster
[preflight] This might take a minute or two, depending on the speed of your internet connection
[preflight] You can also perform this action in beforehand using 'kubeadm config images pull'
[certs] Using certificateDir folder "/etc/kubernetes/pki"
[certs] Generating "ca" certificate and key
[certs] Generating "apiserver" certificate and key
[certs] apiserver serving cert is signed for DNS names [kubernetes kubernetes.default kubernetes.default.svc kubernetes.default.svc.cluster.local master1181] and IPs [10.96.0.1 10.10.11.81]
[certs] Generating "apiserver-kubelet-client" certificate and key
[certs] Generating "front-proxy-ca" certificate and key
[certs] Generating "front-proxy-client" certificate and key
[certs] Generating "etcd/ca" certificate and key
[certs] Generating "etcd/server" certificate and key
[certs] etcd/server serving cert is signed for DNS names [localhost master1181] and IPs [10.10.11.81 127.0.0.1 ::1]
[certs] Generating "etcd/peer" certificate and key
[certs] etcd/peer serving cert is signed for DNS names [localhost master1181] and IPs [10.10.11.81 127.0.0.1 ::1]
[certs] Generating "etcd/healthcheck-client" certificate and key
[certs] Generating "apiserver-etcd-client" certificate and key
[certs] Generating "sa" key and public key
[kubeconfig] Using kubeconfig folder "/etc/kubernetes"
[kubeconfig] Writing "admin.conf" kubeconfig file
[kubeconfig] Writing "kubelet.conf" kubeconfig file
[kubeconfig] Writing "controller-manager.conf" kubeconfig file
[kubeconfig] Writing "scheduler.conf" kubeconfig file
[kubelet-start] Writing kubelet environment file with flags to file "/var/lib/kubelet/kubeadm-flags.env"
[kubelet-start] Writing kubelet configuration to file "/var/lib/kubelet/config.yaml"
[kubelet-start] Starting the kubelet
[control-plane] Using manifest folder "/etc/kubernetes/manifests"
[control-plane] Creating static Pod manifest for "kube-apiserver"
[control-plane] Creating static Pod manifest for "kube-controller-manager"
[control-plane] Creating static Pod manifest for "kube-scheduler"
[etcd] Creating static Pod manifest for local etcd in "/etc/kubernetes/manifests"
[wait-control-plane] Waiting for the kubelet to boot up the control plane as static Pods from directory "/etc/kubernetes/manifests". This can take up to 4m0s
[apiclient] All control plane components are healthy after 22.006207 seconds
[upload-config] Storing the configuration used in ConfigMap "kubeadm-config" in the "kube-system" Namespace
[kubelet] Creating a ConfigMap "kubelet-config-1.19" in namespace kube-system with the configuration for the kubelets in the cluster
[upload-certs] Skipping phase. Please see --upload-certs
[mark-control-plane] Marking the node master1181 as control-plane by adding the label "node-role.kubernetes.io/master=''"
[mark-control-plane] Marking the node master1181 as control-plane by adding the taints [node-role.kubernetes.io/master:NoSchedule]
[bootstrap-token] Using token: yfn8mf.5yckeekleb0yp8m2
[bootstrap-token] Configuring bootstrap tokens, cluster-info ConfigMap, RBAC Roles
[bootstrap-token] configured RBAC rules to allow Node Bootstrap tokens to get nodes
[bootstrap-token] configured RBAC rules to allow Node Bootstrap tokens to post CSRs in order for nodes to get long term certificate credentials
[bootstrap-token] configured RBAC rules to allow the csrapprover controller automatically approve CSRs from a Node Bootstrap Token
[bootstrap-token] configured RBAC rules to allow certificate rotation for all node client certificates in the cluster
[bootstrap-token] Creating the "cluster-info" ConfigMap in the "kube-public" namespace
[kubelet-finalize] Updating "/etc/kubernetes/kubelet.conf" to point to a rotatable kubelet client certificate and key
[addons] Applied essential addon: CoreDNS
[addons] Applied essential addon: kube-proxy

Your Kubernetes control-plane has initialized successfully!

To start using your cluster, you need to run the following as a regular user:

  mkdir -p $HOME/.kube
  sudo cp -i /etc/kubernetes/admin.conf $HOME/.kube/config
  sudo chown $(id -u):$(id -g) $HOME/.kube/config

You should now deploy a pod network to the cluster.
Run "kubectl apply -f [podnetwork].yaml" with one of the options listed at:
  https://kubernetes.io/docs/concepts/cluster-administration/addons/

Then you can join any number of worker nodes by running the following on each as root:

kubeadm join 10.10.11.81:6443 --token yfn8mf.5yckeekleb0yp8m2 \
    --discovery-token-ca-cert-hash sha256:935f610b57d3c170c9849402bef83226258610535b96823e421c20bdc2f83ce2 
</code></pre>
<p>Lưu ý, ta sẽ dùng câu lệnh này để join càc worker vào cluster k8s</p>
<pre class="wp-block-code"><code>kubeadm join 10.10.11.81:6443 --token yfn8mf.5yckeekleb0yp8m2 \
    --discovery-token-ca-cert-hash sha256:935f610b57d3c170c9849402bef83226258610535b96823e421c20bdc2f83ce2 </code></pre>
<p> </p>
<p>Khởi tạo ENV để sử dụng câu lệnh <code>kubectl</code></p>
<pre class="wp-block-code"><code>mkdir -p $HOME/.kube
sudo cp -i /etc/kubernetes/admin.conf $HOME/.kube/config
sudo chown $(id -u):$(id -g) $HOME/.kube/config
</code></pre>
<p>Cấu hình Pod Network, trong bài sẽ sử dụng công nghệ <code>flannel</code></p>
<pre class="wp-block-code"><code>kubectl apply -f https://raw.githubusercontent.com/coreos/flannel/master/Documentation/kube-flannel.yml
</code></pre>
<p>Kết quả</p>
<pre class="wp-block-code"><code>[root@master1181 ~]# kubectl apply -f https://raw.githubusercontent.com/coreos/flannel/master/Documentation/kube-flannel.yml

podsecuritypolicy.policy/psp.flannel.unprivileged created
Warning: rbac.authorization.k8s.io/v1beta1 ClusterRole is deprecated in v1.17+, unavailable in v1.22+; use rbac.authorization.k8s.io/v1 ClusterRole
clusterrole.rbac.authorization.k8s.io/flannel created
Warning: rbac.authorization.k8s.io/v1beta1 ClusterRoleBinding is deprecated in v1.17+, unavailable in v1.22+; use rbac.authorization.k8s.io/v1 ClusterRoleBinding
clusterrolebinding.rbac.authorization.k8s.io/flannel created
serviceaccount/flannel created
configmap/kube-flannel-cfg created
daemonset.apps/kube-flannel-ds created</code></pre>
<h3>Bước 3: Join worker vào Cluster</h3>
<blockquote class="wp-block-quote">
<p>Thực hiện trên worker1182, worker1183</p>
</blockquote>
<p>Thực hiện lần lượt trên worker1182, worker1183</p>
<pre class="wp-block-code"><code>kubeadm join 10.10.11.81:6443 --token yfn8mf.5yckeekleb0yp8m2 \
    --discovery-token-ca-cert-hash sha256:935f610b57d3c170c9849402bef83226258610535b96823e421c20bdc2f83ce2 
</code></pre>
<p>Kết quả:</p>
<pre class="wp-block-code"><code>[root@worker1182 ~]# kubeadm join 10.10.11.81:6443 --token yfn8mf.5yckeekleb0yp8m2 \
&gt;     --discovery-token-ca-cert-hash sha256:935f610b57d3c170c9849402bef83226258610535b96823e421c20bdc2f83ce2 
[preflight] Running pre-flight checks
	[WARNING IsDockerSystemdCheck]: detected "cgroupfs" as the Docker cgroup driver. The recommended driver is "systemd". Please follow the guide at https://kubernetes.io/docs/setup/cri/
[preflight] Reading configuration from the cluster...
[preflight] FYI: You can look at this config file with 'kubectl -n kube-system get cm kubeadm-config -oyaml'
[kubelet-start] Writing kubelet configuration to file "/var/lib/kubelet/config.yaml"
[kubelet-start] Writing kubelet environment file with flags to file "/var/lib/kubelet/kubeadm-flags.env"
[kubelet-start] Starting the kubelet
[kubelet-start] Waiting for the kubelet to perform the TLS Bootstrap...

This node has joined the cluster:
* Certificate signing request was sent to apiserver and a response was received.
* The Kubelet was informed of the new secure connection details.

Run 'kubectl get nodes' on the control-plane to see this node join the cluster.


[root@worker1183 ~]# kubeadm join 10.10.11.81:6443 --token yfn8mf.5yckeekleb0yp8m2 \
&gt;     --discovery-token-ca-cert-hash sha256:935f610b57d3c170c9849402bef83226258610535b96823e421c20bdc2f83ce2 
[preflight] Running pre-flight checks
	[WARNING IsDockerSystemdCheck]: detected "cgroupfs" as the Docker cgroup driver. The recommended driver is "systemd". Please follow the guide at https://kubernetes.io/docs/setup/cri/
[preflight] Reading configuration from the cluster...
[preflight] FYI: You can look at this config file with 'kubectl -n kube-system get cm kubeadm-config -oyaml'
[kubelet-start] Writing kubelet configuration to file "/var/lib/kubelet/config.yaml"
[kubelet-start] Writing kubelet environment file with flags to file "/var/lib/kubelet/kubeadm-flags.env"
[kubelet-start] Starting the kubelet
[kubelet-start] Waiting for the kubelet to perform the TLS Bootstrap...

This node has joined the cluster:
* Certificate signing request was sent to apiserver and a response was received.
* The Kubelet was informed of the new secure connection details.

Run 'kubectl get nodes' on the control-plane to see this node join the cluster.
</code></pre>
<p>Kiểm tra lại trên node master1181</p>
<pre class="wp-block-code"><code>[root@master1181 ~]# kubectl get nodes
NAME         STATUS   ROLES    AGE   VERSION
master1181   Ready    master   11m   v1.19.3
worker1182   Ready    &lt;none&gt;   77s   v1.19.3
worker1183   Ready    &lt;none&gt;   73s   v1.19.3
</code></pre>
<h2>Phần 4. Join worker vào cluster</h2>
<h3><a href="https://github.com/lacoski/kubernetes-note/blob/main/docs/setup/install-k8s-centos7-kubeadm.md#b%C6%B0%E1%BB%9Bc-1-sinh-c%C3%A2u-l%E1%BB%87nh-join-woker"></a>Bước 1: Sinh câu lệnh join woker</h3>
<blockquote class="wp-block-quote">
<p>Thực hiện trên node master1181</p>
</blockquote>
<p>Thực hiện</p>
<pre class="wp-block-code"><code>sudo kubeadm token create --print-join-command
</code></pre>
<p>Kết quả</p>
<pre class="wp-block-code"><code>[root@master1181 ~]# sudo kubeadm token create --print-join-command
W1015 20:24:23.607760   27097 configset.go:348] WARNING: kubeadm cannot validate component configs for API groups [kubelet.config.k8s.io kubeproxy.config.k8s.io]
kubeadm join 10.10.11.81:6443 --token yfn8mf.5yckeekleb0yp8m2     --discovery-token-ca-cert-hash sha256:935f610b57d3c170c9849402bef83226258610535b96823e421c20bdc2f83ce2 
</code></pre>
<h3><a href="https://github.com/lacoski/kubernetes-note/blob/main/docs/setup/install-k8s-centos7-kubeadm.md#b%C6%B0%E1%BB%9Bc-2-th%E1%BB%B1c-hi%E1%BB%87n-c%C3%A2u-l%E1%BB%87nh-tr%C3%AAn-t%E1%BB%ABng-node-worker"></a>Bước 2: Thực hiện câu lệnh trên từng node worker</h3>
<pre class="wp-block-code"><code>kubeadm join 10.10.11.81:6443 --token yfn8mf.5yckeekleb0yp8m2 \
    --discovery-token-ca-cert-hash sha256:935f610b57d3c170c9849402bef83226258610535b96823e421c20bdc2f83ce2 
</code></pre>
<p>Kết quả</p>
<pre class="wp-block-code"><code>[root@worker1182 ~]# kubeadm join 10.10.11.81:6443 --token yfn8mf.5yckeekleb0yp8m2 \
&gt;     --discovery-token-ca-cert-hash sha256:935f610b57d3c170c9849402bef83226258610535b96823e421c20bdc2f83ce2 
[preflight] Running pre-flight checks
	[WARNING IsDockerSystemdCheck]: detected "cgroupfs" as the Docker cgroup driver. The recommended driver is "systemd". Please follow the guide at https://kubernetes.io/docs/setup/cri/
[preflight] Reading configuration from the cluster...
[preflight] FYI: You can look at this config file with 'kubectl -n kube-system get cm kubeadm-config -oyaml'
[kubelet-start] Writing kubelet configuration to file "/var/lib/kubelet/config.yaml"
[kubelet-start] Writing kubelet environment file with flags to file "/var/lib/kubelet/kubeadm-flags.env"
[kubelet-start] Starting the kubelet
[kubelet-start] Waiting for the kubelet to perform the TLS Bootstrap...

This node has joined the cluster:
* Certificate signing request was sent to apiserver and a response was received.
* The Kubelet was informed of the new secure connection details.

Run 'kubectl get nodes' on the control-plane to see this node join the cluster.

[root@worker1183 ~]# kubeadm join 10.10.11.81:6443 --token yfn8mf.5yckeekleb0yp8m2 \
&gt;     --discovery-token-ca-cert-hash sha256:935f610b57d3c170c9849402bef83226258610535b96823e421c20bdc2f83ce2 
[preflight] Running pre-flight checks
	[WARNING IsDockerSystemdCheck]: detected "cgroupfs" as the Docker cgroup driver. The recommended driver is "systemd". Please follow the guide at https://kubernetes.io/docs/setup/cri/
[preflight] Reading configuration from the cluster...
[preflight] FYI: You can look at this config file with 'kubectl -n kube-system get cm kubeadm-config -oyaml'
[kubelet-start] Writing kubelet configuration to file "/var/lib/kubelet/config.yaml"
[kubelet-start] Writing kubelet environment file with flags to file "/var/lib/kubelet/kubeadm-flags.env"
[kubelet-start] Starting the kubelet
[kubelet-start] Waiting for the kubelet to perform the TLS Bootstrap...

This node has joined the cluster:
* Certificate signing request was sent to apiserver and a response was received.
* The Kubelet was informed of the new secure connection details.

Run 'kubectl get nodes' on the control-plane to see this node join the cluster.
</code></pre>
<h3><a href="https://github.com/lacoski/kubernetes-note/blob/main/docs/setup/install-k8s-centos7-kubeadm.md#b%C6%B0%E1%BB%9Bc-3-ki%E1%BB%83m-tra-t%E1%BA%A1i-node-master1181"></a>Bước 3: Kiểm tra tại node master1181</h3>
<pre class="wp-block-code"><code>[root@master1181 ~]# kubectl get nodes
NAME         STATUS   ROLES    AGE     VERSION
master1181   Ready    master   7m46s   v1.19.3
worker1182   Ready    &lt;none&gt;   46s     v1.19.3
worker1183   Ready    &lt;none&gt;   43s     v1.19.3

[root@master1181 ~]# kubectl get pod --all-namespaces
NAMESPACE     NAME                                 READY   STATUS    RESTARTS   AGE
kube-system   coredns-f9fd979d6-wwbz9              1/1     Running   0          7m35s
kube-system   coredns-f9fd979d6-x28f7              1/1     Running   0          7m35s
kube-system   etcd-master1181                      1/1     Running   0          7m45s
kube-system   kube-apiserver-master1181            1/1     Running   0          7m45s
kube-system   kube-controller-manager-master1181   1/1     Running   0          7m45s
kube-system   kube-flannel-ds-mjcgd                1/1     Running   0          56s
kube-system   kube-flannel-ds-rm5sk                1/1     Running   0          2m19s
kube-system   kube-flannel-ds-vrwpz                1/1     Running   0          53s
kube-system   kube-proxy-b7b9t                     1/1     Running   0          7m35s
kube-system   kube-proxy-fdmlr                     1/1     Running   0          53s
kube-system   kube-proxy-nx5nq                     1/1     Running   0          56s
kube-system   kube-scheduler-master1181            1/1     Running   0          7m45s</code></pre>
<h2>Phần 5: Triển khai ứng dụng demo</h2>
<blockquote class="wp-block-quote">
<p>Thực hiện trên master1181</p>
</blockquote>
<p>Tạo mới file <code>hello-app.yml</code> với nội dung</p>
<pre class="wp-block-code"><code>apiVersion: apps/v1
kind: Deployment
metadata:
  name: hello-app
spec:
  replicas: 2
  selector:
    matchLabels:
      app: hello-app 
  template:
    metadata:
      labels:
        app: hello-app
    spec:
      containers:
      - image: gcr.io/google-samples/hello-app:1.0
        imagePullPolicy: Always
        name: hello-app
        ports:
        - containerPort: 8080
---
apiVersion: v1
kind: Service
metadata:
  name: hello-app
spec:
  type: NodePort
  ports:
    - port: 8080
      targetPort: 8080
      nodePort: 30001
      protocol: TCP
  selector:
    app: hello-app
</code></pre>
<p>Thực hiện deploy ứng dụng</p>
<pre class="wp-block-code"><code>kubectl create -f hello-app.yml
</code></pre>
<p>Kết quả</p>
<pre class="wp-block-code"><code>[root@master1181 ~]# kubectl create -f hello-app.yml
deployment.apps/hello-app created
service/hello-app created
</code></pre>
<p>Kiểm tra</p>
<pre class="wp-block-code"><code>kubectl get deployments hello-app
kubectl describe deployments hello-app
kubectl get replicasets
kubectl describe replicasets
kubectl get services hello-app
</code></pre>
<p>Kết quả</p>
<pre class="wp-block-code"><code>[root@master1181 ~]# kubectl get deployments hello-app
NAME        READY   UP-TO-DATE   AVAILABLE   AGE
hello-app   2/2     2            2           25s
[root@master1181 ~]# kubectl describe deployments hello-app
Name:                   hello-app
Namespace:              default
CreationTimestamp:      Thu, 15 Oct 2020 19:39:29 +0700
Labels:                 &lt;none&gt;
Annotations:            deployment.kubernetes.io/revision: 1
Selector:               app=hello-app
Replicas:               2 desired | 2 updated | 2 total | 2 available | 0 unavailable
StrategyType:           RollingUpdate
MinReadySeconds:        0
RollingUpdateStrategy:  25% max unavailable, 25% max surge
Pod Template:
  Labels:  app=hello-app
  Containers:
   hello-app:
    Image:        gcr.io/google-samples/hello-app:1.0
    Port:         8080/TCP
    Host Port:    0/TCP
    Environment:  &lt;none&gt;
    Mounts:       &lt;none&gt;
  Volumes:        &lt;none&gt;
Conditions:
  Type           Status  Reason
  ----           ------  ------
  Available      True    MinimumReplicasAvailable
  Progressing    True    NewReplicaSetAvailable
OldReplicaSets:  &lt;none&gt;
NewReplicaSet:   hello-app-59cb9bf65 (2/2 replicas created)
Events:
  Type    Reason             Age   From                   Message
  ----    ------             ----  ----                   -------
  Normal  ScalingReplicaSet  30s   deployment-controller  Scaled up replica set hello-app-59cb9bf65 to 2
[root@master1181 ~]# kubectl get replicasets
NAME                  DESIRED   CURRENT   READY   AGE
hello-app-59cb9bf65   2         2         2       34s
[root@master1181 ~]# kubectl describe replicasets
Name:           hello-app-59cb9bf65
Namespace:      default
Selector:       app=hello-app,pod-template-hash=59cb9bf65
Labels:         app=hello-app
                pod-template-hash=59cb9bf65
Annotations:    deployment.kubernetes.io/desired-replicas: 2
                deployment.kubernetes.io/max-replicas: 3
                deployment.kubernetes.io/revision: 1
Controlled By:  Deployment/hello-app
Replicas:       2 current / 2 desired
Pods Status:    2 Running / 0 Waiting / 0 Succeeded / 0 Failed
Pod Template:
  Labels:  app=hello-app
           pod-template-hash=59cb9bf65
  Containers:
   hello-app:
    Image:        gcr.io/google-samples/hello-app:1.0
    Port:         8080/TCP
    Host Port:    0/TCP
    Environment:  &lt;none&gt;
    Mounts:       &lt;none&gt;
  Volumes:        &lt;none&gt;
Events:
  Type    Reason            Age   From                   Message
  ----    ------            ----  ----                   -------
  Normal  SuccessfulCreate  41s   replicaset-controller  Created pod: hello-app-59cb9bf65-p2kz9
  Normal  SuccessfulCreate  41s   replicaset-controller  Created pod: hello-app-59cb9bf65-cx6kg
[root@master1181 ~]# kubectl get services hello-app
NAME        TYPE       CLUSTER-IP      EXTERNAL-IP   PORT(S)          AGE
hello-app   NodePort   10.98.138.202   &lt;none&gt;        8080:30001/TCP   47s
</code></pre>
<p>Truy cập web với đường dẫn <a href="http://10.10.11.81:30001/">http://10.10.11.81:30001/</a>, <a href="http://10.10.11.82:30001/">http://10.10.11.82:30001/</a>, <a href="http://10.10.11.83:30001/">http://10.10.11.83:30001/</a></p>
<p>Kết quả</p>
<figure class="wp-block-image size-large"><figure class="wp-image-524"><img loading="lazy"  src="https://blog.devopsviet.com/wp-content/uploads/2021/08/pic3-6-1024x560.png" data-is-external-image="true"  sizes="(max-width: 1024px) 100vw, 1024px" srcset="https://blog.devopsviet.com/wp-content/uploads/2021/08/pic3-6-1024x560.png 1024w, https://blog.devopsviet.com/wp-content/uploads/2021/08/pic3-6-300x164.png 300w, https://blog.devopsviet.com/wp-content/uploads/2021/08/pic3-6-768x420.png 768w, https://blog.devopsviet.com/wp-content/uploads/2021/08/pic3-6-1536x840.png 1536w, https://blog.devopsviet.com/wp-content/uploads/2021/08/pic3-6-816x446.png 816w, https://blog.devopsviet.com/wp-content/uploads/2021/08/pic3-6.png 1922w" alt="" width="1024" height="560" loading="lazy"></figure></figure>
<p> </p>
<h2>Tài liệu tham khảo</h2>
<figure class="wp-block-embed">
<div class="wp-block-embed__wrapper">https://github.com/hocchudong/ghichep-kubernetes/blob/master/docs/kubernetes-5min/02.Caidat-Kubernetes.md</div>
</figure>
<figure class="wp-block-embed">
<div class="wp-block-embed__wrapper">https://kubernetes.io/docs/setup/production-environment/tools/kubeadm/create-cluster-kubeadm/</div>
</figure>
            ]]>
        </content>
    </entry>
    <entry>
        <title>[Kubernetes] Phần 12: Khái niệm Helm</title>
        <author>
            <name>Duong Dinh Trung</name>
        </author>
        <link href="http://blog.dtrungit.ga/kubernetes-phan-12-khai-niem-helm/index.html"/>
        <id>http://blog.dtrungit.ga/kubernetes-phan-12-khai-niem-helm/index.html</id>
            <category term="Linux"/>
            <category term="K8s"/>

        <updated>2022-06-15T15:28:54+07:00</updated>
            <summary>
                <![CDATA[
                        <img src="http://blog.dtrungit.ga/media/posts/127/k8s.png" alt="" />
                    Tổng quan Helm là trình quản lý gói dành riêng cho Kubernetes. Giống các hệ điều hành CentOS dùng Yum&hellip;
                ]]>
            </summary>
        <content type="html">
            <![CDATA[
                    <img src="http://blog.dtrungit.ga/media/posts/127/k8s.png" alt="" />
                <h2>Tổng quan</h2>
<p>Helm là trình quản lý gói dành riêng cho Kubernetes. Giống các hệ điều hành CentOS dùng Yum hoặc Ubuntu dùng APT, K8s cũng cần công cụ quản lý dịch vụ chạy trên Cluster K8s. Với Helm, thao tác quản lý các service sẽ đơn giản hơn khi sử dụng kubectl định nghĩa hoặc khai báo các service. Ngoài ra Helm cũng cho phép chia sẻ resource Helm, tức sẽ có các tổ chức cung cấp các Helm Chart (Helm Hub) có sẵn để chúng ta triển khai các dịch vụ nhanh hơn (wordpress, SELK, …)</p>
<p>Sử dụng Helm trong các trường hợp sau:</p>
<ul>
<li>Cài đặt Apache, Nginx</li>
<li>Cài đặt MariaDB, MySQL</li>
<li>Cài đặt WordPress</li>
<li>Cài đặt SELK</li>
<li>v.v..</li>
</ul>
<h2><a href="https://github.com/lacoski/kubernetes-note/blob/main/docs/3-helm-k8s.md#c%C3%A1c-kh%C3%A1i-ni%E1%BB%87m"></a>Các khái niệm</h2>
<ul>
<li>Chart: tập hợp file YAML template, đây là các file khai báo các source cần thiết để khởi tạo 1 ứng dụng. VD: Triển khai WordPress trên k8s cần các Image Docker như Source code, database, thì Helm sẽ tổ chức các Image cần thiết để khởi tạo ra ứng dụng.</li>
<li>Config: nằm trong file values.yml, chứa nhưng khai báo về Image sử dụng, các biến môi trường, các Secret cần thiết để từ Template Helm khởi tạo ra services hoàn chỉnh (VD: Ingress, Deployment, ….)</li>
<li>Release: là một version của K8s application đang chạy dựa trên Chart và kết hợp với một Config cụ thể.</li>
<li>Repositories: Helm Charts có thể được publish thông qua nhiều repo khác nhau. Nó có thể là những private repo chỉ dùng trong nội bộ công ty, hoặc public thông qua Helm Hub. Một số Chart có thể có nhiều phiên bản của từng công ty hoặc publisher khác nhau. Riêng những Chart trong repo Stable thì luôn phải đáp ứng được tiêu chí từ Technical Requirements của Helm.</li>
</ul>
<h2><a href="https://github.com/lacoski/kubernetes-note/blob/main/docs/3-helm-k8s.md#ki%E1%BA%BFn-tr%C3%BAc"></a>Kiến trúc</h2>
<p>Helm sử dụng kiến trúc client-server gồm:</p>
<ul>
<li>Client CLI</li>
<li>Server chạy trong Kubernetes cluster</li>
</ul>
<p>Helm Client (Client CLI):</p>
<ul>
<li>Cung cấp CLI cho phép Developer quản lý, khởi tạo, phát triển các Charts, Config, Release, Repositores.</li>
<li>Helm Client sẽ tương tác với Tiller Server, để thực hiện các hành động khác nhau như install, upgrade và rollback với những Charts, Release.</li>
</ul>
<p>Tiller Server:</p>
<ul>
<li>Server nằm trong Kubernetes cluster, tương tác với Helm Client và giao tiếp Kubernetes API server.</li>
<li>Từ đó, Helm có thể dễ dàng quản lý Kubernetes với các tác vụ như install, upgrade, query và remove đối với Kubernetes resources.</li>
</ul>
<h2><a href="https://github.com/lacoski/kubernetes-note/blob/main/docs/3-helm-k8s.md#c%E1%BA%A5u-tr%C3%BAc-1-helm-package"></a>Cấu trúc 1 Helm Package</h2>
<pre class="wp-block-code"><code>[root@master1181 apache]# tree
.
├── charts
│   └── common
│       ├── Chart.yaml
│       ├── README.md
│       ├── templates
│       │   ├── _affinities.tpl
│       │   ├── _capabilities.tpl
│       │   ├── _errors.tpl
│       │   ├── _images.tpl
│       │   ├── _labels.tpl
│       │   ├── _names.tpl
│       │   ├── _secrets.tpl
│       │   ├── _storage.tpl
│       │   ├── _tplvalues.tpl
│       │   ├── _utils.tpl
│       │   ├── _validations.tpl
│       │   └── _warnings.tpl
│       └── values.yaml
├── Chart.yaml
├── ci
│   └── ct-values.yaml
├── files
│   ├── README.md
│   └── vhosts
│       └── README.md
├── README.md
├── requirements.lock
├── requirements.yaml
├── templates
│   ├── configmap-vhosts.yaml
│   ├── configmap.yaml
│   ├── deployment.yaml
│   ├── _helpers.tpl
│   ├── ingress.yaml
│   ├── NOTES.txt
│   └── svc.yaml
├── values.schema.json
└── values.yaml

7 directories, 31 files
</code></pre>
<p>Vai trò của các file và thư mục như sau:</p>
<ul>
<li><code>charts</code>: những chart phụ thuộc có thể để vào đây tuy nhiên vẫn nên dùng requirements.yaml để link các chart phụ thuộc linh động hơn.</li>
<li><code>templates</code>: chứa những template file để khi kết hợp với các biến config (từ values.yaml và command-line) tạo thành các manifest file cho Kubernetes. Lưu ý: template file sử dụng format của ngôn ngữ lập trình Go.</li>
<li><code>Chart.yaml</code>: yaml file chứa các thông tin liên quan đến định nghĩa Chart như tên, version, …</li>
<li><code>LICENSE/</code>: license cho việc sử dụng Chart.</li>
<li><code>README.md</code>: miêu tả thông tin và cách sử dụng Chart tương tự README.md trong các project trên Github.</li>
<li><code>requirements.yaml</code>: yaml file chứa danh sách các link của các chart phụ thuộc.</li>
<li><code>values.yaml</code>: yaml file chứa các biến config mặc định cho Chart.</li>
</ul>
<h2><a href="https://github.com/lacoski/kubernetes-note/blob/main/docs/3-helm-k8s.md#ngu%E1%BB%93n"></a>Nguồn</h2>
<p><a href="https://helm.sh/docs/">https://helm.sh/docs/</a></p>
<p><a href="https://viblo.asia/p/helm-la-gi-no-co-lien-quan-gi-den-series-nay-Do754oAQlM6">https://viblo.asia/p/helm-la-gi-no-co-lien-quan-gi-den-series-nay-Do754oAQlM6</a></p>
            ]]>
        </content>
    </entry>
    <entry>
        <title>[Kubernetes] Phần 11: Khái niệm Ingress</title>
        <author>
            <name>Duong Dinh Trung</name>
        </author>
        <link href="http://blog.dtrungit.ga/kubernetes-phan-11-khai-niem-ingress/index.html"/>
        <id>http://blog.dtrungit.ga/kubernetes-phan-11-khai-niem-ingress/index.html</id>
            <category term="Linux"/>
            <category term="K8s"/>

        <updated>2022-06-15T15:28:31+07:00</updated>
            <summary>
                <![CDATA[
                        <img src="http://blog.dtrungit.ga/media/posts/126/k8s.png" alt="" />
                    Tổng quan Trong K8s, Ingress là đối tượng sử dụng để expose service nằm bên trong Cluster ra bên ngoài&hellip;
                ]]>
            </summary>
        <content type="html">
            <![CDATA[
                    <img src="http://blog.dtrungit.ga/media/posts/126/k8s.png" alt="" />
                <h2>Tổng quan</h2>
<p>Trong K8s, Ingress là đối tượng sử dụng để expose service nằm bên trong Cluster ra bên ngoài Internet. Với Ingress, ta có thể tạo ra nhiều rule khác nhau để điều tiết traffic tới các services. Sử dụng Ingress để expose service sẽ đơn giản hơn sử dụng Load Balancer và expose service trên từng Node</p>
<p>Ví dụ:</p>
<ul>
<li>Khi có request tới domain <code>example.com/api/v1/</code> sẽ tới <code>api-v1 service</code>,</li>
<li>Khi có request tới domain <code>example.com/api/v2/</code> sẽ tới <code>api-v2 service</code>,</li>
</ul>
<h2><a href="https://github.com/lacoski/kubernetes-note/blob/main/docs/2.9-ingress-k8s.md#th%E1%BA%BF-n%C3%A0o-l%C3%A0-ingress-controller"></a>Thế nào là Ingress Controller?</h2>
<p>Ingress Controller là một ứng dụng chạy trong một cluster và sử dụng cấu hình LoadBalancer HTTP theo tài nguyên Ingress. Loadbalancer này có thể là chạy bằng phần mềm trong cluster (MetalLB), Loadbalancer phần cứng hoặc là Loadbalancer dịch vụ cloud bên ngoài. Với mỗi LoadBalancer khác nhau đòi hỏi phải thực hiện Ingress Controller khác nhau.</p>
<h2><a href="https://github.com/lacoski/kubernetes-note/blob/main/docs/2.9-ingress-k8s.md#kubernetes-ingress-vs-loadbalancer-vs-nodeport"></a>Kubernetes Ingress vs LoadBalancer vs NodePort</h2>
<p>Các option trên đều sử dụng với mục đích Expose service từ nội bộ Cluster ra bên ngoài internet.</p>
<h3><a href="https://github.com/lacoski/kubernetes-note/blob/main/docs/2.9-ingress-k8s.md#nodeport"></a>NodePort</h3>
<p>Đánh giá:</p>
<ul>
<li>Phương pháp cấu hình đơn giản, service được chọn dạng NodePort. Sau đó K8s sẽ cấp 1 Port xác định trên mỗi node thuộc Cluster cho service.</li>
<li>Tất cả traffic tới Port sẽ được forward vào bên trong Service và tới các Pod bên trong</li>
<li>Phương pháp có nhược điểm, quản lý Port cấp phát không rõ ràng, đôi khi cấp phát port chồng chéo</li>
</ul>
<figure class="wp-block-image size-full"><figure class="wp-image-515"><img loading="lazy"  src="https://blog.devopsviet.com/wp-content/uploads/2021/08/pic1-8.png" data-is-external-image="true"  sizes="(max-width: 878px) 100vw, 878px" srcset="https://blog.devopsviet.com/wp-content/uploads/2021/08/pic1-8.png 878w, https://blog.devopsviet.com/wp-content/uploads/2021/08/pic1-8-300x246.png 300w, https://blog.devopsviet.com/wp-content/uploads/2021/08/pic1-8-768x630.png 768w, https://blog.devopsviet.com/wp-content/uploads/2021/08/pic1-8-816x669.png 816w" alt="" width="878" height="720" loading="lazy"></figure></figure>
<h3>LoadBalancer</h3>
<p>Đánh giá:</p>
<ul>
<li>Phương pháp cấu hình LoadBalancer khá giống NodePort – Sử dụng file YAML</li>
<li>Tuy nhiên phương pháp yêu cầu External Loadblancer, thường được cung cấp bởi các cloud providerm, không sẵn khi cài Kubernetes mặc định.</li>
<li>Với phương pháp cài thủ công, phải triển khai thêm thành phần LB khá phức tạp</li>
<li>Khi có thành phần LB, mỗi khi tạo mới 1 service, thành phần LB sẽ cấp cho Service 1 IP External để người dùng truy cập. Đây cũng là IP để expose service k8s ra ngoài Internet.</li>
</ul>
<figure class="wp-block-image size-full"><figure class="wp-image-516"><img loading="lazy"  src="https://blog.devopsviet.com/wp-content/uploads/2021/08/pic2-5.png" data-is-external-image="true"  sizes="(max-width: 800px) 100vw, 800px" srcset="https://blog.devopsviet.com/wp-content/uploads/2021/08/pic2-5.png 800w, https://blog.devopsviet.com/wp-content/uploads/2021/08/pic2-5-262x300.png 262w, https://blog.devopsviet.com/wp-content/uploads/2021/08/pic2-5-768x880.png 768w" alt="" width="800" height="917" loading="lazy"></figure></figure>
<h3>Ingress</h3>
<p>Đánh giá:</p>
<ul>
<li>NodePort và LoadBalancer expose service bằng cách chỉ định service type. Ingress tiếp cập theo phương pháp khác</li>
<li>Với Ingress, tập trung vào điều phối HTTP và HTTPs Request từ bên ngoài vào trong Cluster</li>
<li>Có thể sử dụng kết hợp Ingress + LB hoặc Ingress + NodePort.</li>
<li>Nếu sử dụng Ingress + NodePort thì ta sẽ không cần triển khai thành phần LB. Nhược điểm, chỉ có thể Expose Port từ <code>30000-32767</code></li>
</ul>
<p>VD:</p>
<ul>
<li>Khi có request tới domain <code>example.com/api/v1/</code> sẽ tới <code>api-v1 service</code>,</li>
<li>Khi có request tới domain <code>example.com/api/v2/</code> sẽ tới <code>api-v2 service</code>,</li>
</ul>
<p>Các loại Ingress Controller thông dụng:</p>
<ul>
<li>NGINX Ingress Controller</li>
<li>HAProxy Ingress Controller</li>
<li> </li>
</ul>
<figure class="wp-block-image size-full"><figure class="wp-image-517"><img loading="lazy"  src="https://blog.devopsviet.com/wp-content/uploads/2021/08/pic3-5.png" data-is-external-image="true"  sizes="(max-width: 805px) 100vw, 805px" srcset="https://blog.devopsviet.com/wp-content/uploads/2021/08/pic3-5.png 805w, https://blog.devopsviet.com/wp-content/uploads/2021/08/pic3-5-300x294.png 300w, https://blog.devopsviet.com/wp-content/uploads/2021/08/pic3-5-768x754.png 768w" alt="" width="805" height="790" loading="lazy"></figure></figure>
<h2>Nguồn</h2>
<p><a href="https://collabnix.github.io/kubelabs/Ingress101/">https://collabnix.github.io/kubelabs/Ingress101/</a></p>
<p><a href="https://kubernetes.io/docs/concepts/services-networking/ingress/">https://kubernetes.io/docs/concepts/services-networking/ingress/</a></p>
            ]]>
        </content>
    </entry>
    <entry>
        <title>[Kubernetes] Phần 10: Khái niệm Job</title>
        <author>
            <name>Duong Dinh Trung</name>
        </author>
        <link href="http://blog.dtrungit.ga/kubernetes-phan-10-khai-niem-job/index.html"/>
        <id>http://blog.dtrungit.ga/kubernetes-phan-10-khai-niem-job/index.html</id>
            <category term="Linux"/>
            <category term="K8s"/>

        <updated>2022-06-15T15:28:01+07:00</updated>
            <summary>
                <![CDATA[
                        <img src="http://blog.dtrungit.ga/media/posts/125/k8s.png" alt="" />
                    Tổng quan Khi triển khai, vận hành hệ thống, chúng ta sẽ có nhiều tác vụ (Job) cần thực hiện&hellip;
                ]]>
            </summary>
        <content type="html">
            <![CDATA[
                    <img src="http://blog.dtrungit.ga/media/posts/125/k8s.png" alt="" />
                <h2>Tổng quan</h2>
<p>Khi triển khai, vận hành hệ thống, chúng ta sẽ có nhiều tác vụ (Job) cần thực hiện định kỳ hoặc 1 lần.</p>
<p>Các ví dụ:</p>
<ul>
<li>Thực hiện backup database</li>
<li>Thực hiện backup dữ liệu</li>
<li>Thực hiện backup source code</li>
<li>Thực hiện báo cáo tài nguyên</li>
<li>v.v..</li>
</ul>
<p>Để giải quyết bài toán trên, K8s sinh ra resource <code>Job</code>.</p>
<p>Các Job chạy trong K8s sẽ thực hiện bên trong các Pod. Các Pod sẽ tạo ra khi có Job chạy và kết thúc khi Job thành công. Khi ta xóa Job thì các Pod liên quan cũng được xóa theo.</p>
<h2><a href="https://github.com/lacoski/kubernetes-note/blob/main/docs/2.8-job-k8s.md#cronjob-trong-kubernetes"></a>CronJob trong Kubernetes</h2>
<p>Giống như Cronjob trong Linux, CronJob trong Kubernetes dùng để chạy các tác vụ tại một thời điểm cụ thể hoặc tại các khoảng thời gian được quy định.</p>
<p>Các ví dụ</p>
<ul>
<li>Thực hiện backup database</li>
<li>Thực hiện backup dữ liệu</li>
<li>Thực hiện backup source code</li>
</ul>
<h2><a href="https://github.com/lacoski/kubernetes-note/blob/main/docs/2.8-job-k8s.md#ngu%E1%BB%93n"></a>Nguồn</h2>
<p><a href="https://collabnix.github.io/kubelabs/Jobs101/#creating-your-first-kubernetes-job">https://collabnix.github.io/kubelabs/Jobs101/#creating-your-first-kubernetes-job</a></p>
            ]]>
        </content>
    </entry>
    <entry>
        <title>[Kubernetes] Phần 9: Khái niệm DaemonSet</title>
        <author>
            <name>Duong Dinh Trung</name>
        </author>
        <link href="http://blog.dtrungit.ga/kubernetes-phan-9-khai-niem-daemonset/index.html"/>
        <id>http://blog.dtrungit.ga/kubernetes-phan-9-khai-niem-daemonset/index.html</id>
            <category term="Linux"/>
            <category term="K8s"/>

        <updated>2022-06-15T15:27:19+07:00</updated>
            <summary>
                <![CDATA[
                        <img src="http://blog.dtrungit.ga/media/posts/124/k8s.png" alt="" />
                    Tổng quan Bài toán, khi triển khai mô hình cluster nhiều node ta sẽ gặp bài toán làm sao để&hellip;
                ]]>
            </summary>
        <content type="html">
            <![CDATA[
                    <img src="http://blog.dtrungit.ga/media/posts/124/k8s.png" alt="" />
                <h2>Tổng quan</h2>
<p>Bài toán, khi triển khai mô hình cluster nhiều node ta sẽ gặp bài toán làm sao để triển khai agent giám sát tới mỗi node. Và với mô hình Cluster K8s, ứng dụng được chạy trong pod, vậy làm sao để thu thập metric của các Pod chạy trong từng node, làm sao bảo đảm khi có Node Worker mới join vào Cluster sẽ tự có agent được triển khai trên node đó và tự mất đi khi có Worker out khỏi Cluster.</p>
<p>Để giải quyết bài toán này, K8s sinh ra resource <code>DaemonSets</code>. DaemonSets sử dụng để bảo đảm 1 tập hoặc tất cả các K8s node sẽ chạy 1 bản copy của pod. Khi thêm mới Node vào K8s Cluster, sẽ tự có Pod triển khai vào node mới. Khi out worker khỏi node, Pod sẽ tự mất đi.</p>
<p>DaemonSet là phương pháp quản lý Pod khác, giống như <code>Deployments</code>, <code>ReplicaSets</code>, <code>StatefulSets</code>. Nó sinh ra với mục tiêu duy nhất, bảo đảm sẽ có Pod (triển khai dạng DaemonSet) được triển khai trên toàn bộ các node thuộc Cluster.</p>
<p>Ví dụ điển hình nhất của DaemonSet là logging và monitoring các Pod, Node thuộc Cluster</p>
<h2><a href="https://github.com/lacoski/kubernetes-note/blob/main/docs/2.7-ds-k8s.md#c%C3%A1c-v%C3%AD-d%E1%BB%A5-s%E1%BB%AD-d%E1%BB%A5ng-daemonset"></a>Các ví dụ sử dụng DaemonSet</h2>
<ul>
<li>To run a daemon for cluster storage on each node, such as: – glusterd – ceph</li>
<li>To run a daemon for logs collection on each node, such as: – fluentd – logstash</li>
<li>To run a daemon for node monitoring on ever note, such as: – Prometheus Node Exporter – collectd – Datadog agent</li>
</ul>
<h2><a href="https://github.com/lacoski/kubernetes-note/blob/main/docs/2.7-ds-k8s.md#ngu%E1%BB%93n"></a>Nguồn</h2>
<p><a href="https://collabnix.github.io/kubelabs/DaemonSet101/">https://collabnix.github.io/kubelabs/DaemonSet101/</a></p>
<p><a href="https://kubernetes.io/docs/concepts/workloads/controllers/daemonset/">https://kubernetes.io/docs/concepts/workloads/controllers/daemonset/</a></p>
            ]]>
        </content>
    </entry>
    <entry>
        <title>[Kubernetes] Phần 8: Khái niệm Statefulset</title>
        <author>
            <name>Duong Dinh Trung</name>
        </author>
        <link href="http://blog.dtrungit.ga/kubernetes-phan-8-khai-niem-statefulset/index.html"/>
        <id>http://blog.dtrungit.ga/kubernetes-phan-8-khai-niem-statefulset/index.html</id>
            <category term="Linux"/>
            <category term="K8s"/>

        <updated>2022-06-15T15:26:55+07:00</updated>
            <summary>
                <![CDATA[
                        <img src="http://blog.dtrungit.ga/media/posts/123/k8s.png" alt="" />
                    1. Tổng quan Statefulset được sử dụng để quản trị một hoặc nhiều Pod. Vậy tại sao lại cần Statefulset khi đã&hellip;
                ]]>
            </summary>
        <content type="html">
            <![CDATA[
                    <img src="http://blog.dtrungit.ga/media/posts/123/k8s.png" alt="" />
                <h2>1. Tổng quan</h2>
<p>Statefulset được sử dụng để quản trị một hoặc nhiều Pod.</p>
<p>Vậy tại sao lại cần <code>Statefulset</code> khi đã có <code>ReplicateSet</code>, <code>Deployment</code>?</p>
<h2><a href="https://github.com/lacoski/kubernetes-note/blob/main/docs/2.6-sfs-k8s.md#s%E1%BB%B1-kh%C3%A1c-bi%E1%BB%87t-gi%E1%BB%AFa-statefulset-v%C3%A0-replicateset"></a>2. Sự khác biệt giữa Statefulset và ReplicateSet</h2>
<p>Để hiểu rõ ta cần bắt đầu lại tự khái niệm:</p>
<ul>
<li>Ứng dụng dạng <code>stateless</code>:
<ul>
<li>Các ứng dụng stateless thường là các service dụng <code>nginx, apache</code> hoặc chạy dạng HTTP Request. Gọi là stateless app vì mỗi request tới <code>nginx hoặc apache</code> chúng sẽ độc lập với nhau.</li>
<li>VD: Gửi HTTP tới Backend API, mỗi API sẽ độc lập không ảnh hưởng tới các API khác.</li>
</ul>
</li>
<li>Ứng dụng dạng <code>stateful</code>:
<ul>
<li>Các ứng dụng stateful thường là các service dạng database, điển hình nhất là <code>mariadb, mysql</code>.</li>
<li>VD: Các database như <code>mariadb hoặc mysql</code> sẽ gặp phải vấn đề chỉ có thể ghi trên 1 node và ghi trên nhiều node.</li>
<li>Và các database dạng <code>mysql, mariadb</code> không thể scale hàng loạt bởi lý do cơ chế master slave, cơ chế ghi 1 đọc nhiều node ..</li>
</ul>
</li>
</ul>
<p>Qua đó, Deployment phù hợp hơn cho các ứng dụng dạng stateless, khi mà pod có thể sinh ra và mất đi linh hoạt</p>
<p><code>Statefulset</code> sinh ra khi phải quản lý pod chặt chẽ, ví dụ triển khai cụm mariadb master slave 3 node trên k8s.</p>
<figure class="wp-block-image size-full"><figure class="wp-image-505"><img loading="lazy"  src="https://blog.devopsviet.com/wp-content/uploads/2021/08/pic1-7.png" data-is-external-image="true"  sizes="(max-width: 938px) 100vw, 938px" srcset="https://blog.devopsviet.com/wp-content/uploads/2021/08/pic1-7.png 938w, https://blog.devopsviet.com/wp-content/uploads/2021/08/pic1-7-283x300.png 283w, https://blog.devopsviet.com/wp-content/uploads/2021/08/pic1-7-768x815.png 768w, https://blog.devopsviet.com/wp-content/uploads/2021/08/pic1-7-816x866.png 816w" alt="" width="938" height="996" loading="lazy"></figure></figure>
<figure class="wp-block-image size-large"><figure class="wp-image-506"><img loading="lazy"  src="https://blog.devopsviet.com/wp-content/uploads/2021/08/pic2-1024x454.jpg" data-is-external-image="true"  sizes="(max-width: 1024px) 100vw, 1024px" srcset="https://blog.devopsviet.com/wp-content/uploads/2021/08/pic2-1024x454.jpg 1024w, https://blog.devopsviet.com/wp-content/uploads/2021/08/pic2-300x133.jpg 300w, https://blog.devopsviet.com/wp-content/uploads/2021/08/pic2-768x341.jpg 768w, https://blog.devopsviet.com/wp-content/uploads/2021/08/pic2-816x362.jpg 816w, https://blog.devopsviet.com/wp-content/uploads/2021/08/pic2.jpg 1159w" alt="" width="1024" height="454" loading="lazy"></figure></figure>
<h2>3. Khái niệm headless Service</h2>
<p>Thông thường khi tạo deployment, expose service ra bên ngoài chúng ta sẽ khởi tạo một Service để load-balance traffic xuống các Pod.</p>
<p>Vậy, đặt câu hỏi “Có cách để chúng ta có thể truy cập trực tiếp các Pod IP thông qua DNS endpoint nội bộ?”</p>
<p>Để giải quyết bài toán này, k8s sinh ra khái niệm “Headless Service”. Với Headless Service, chúng ta có thể kết nối trực tiếp với Pods.</p>
<p>Ví dụ, điển hình nhất cần sử dụng <code>Headless Service</code> là bài toán triển khai database trong k8s.</p>
<p>VD: Triển khai cụm database 3 node Master Slave Mariadb dạng <code>Statefulset</code>, thì việc đọc ghi chỉ thực hiện trên 1 node Master. Với trường này ta sẽ sử dụng <code>Headless service</code>.</p>
<figure class="wp-block-image size-full"><figure class="wp-image-507"><img loading="lazy"  src="https://blog.devopsviet.com/wp-content/uploads/2021/08/pic3-4.png" data-is-external-image="true"  sizes="(max-width: 938px) 100vw, 938px" srcset="https://blog.devopsviet.com/wp-content/uploads/2021/08/pic3-4.png 938w, https://blog.devopsviet.com/wp-content/uploads/2021/08/pic3-4-283x300.png 283w, https://blog.devopsviet.com/wp-content/uploads/2021/08/pic3-4-768x815.png 768w, https://blog.devopsviet.com/wp-content/uploads/2021/08/pic3-4-816x866.png 816w" alt="" width="938" height="996" loading="lazy"></figure></figure>
<h2>Nguồn</h2>
<figure class="wp-block-embed is-type-wp-embed is-provider-technology-diver wp-block-embed-technology-diver">
<div class="wp-block-embed__wrapper"><div class="post__iframe"><iframe loading="lazy" width="600" height="533" class="wp-embedded-content" sandbox="allow-scripts" security="restricted" title="“Headless Service trong Kubernetes là gì ?” — Technology Diver" src="https://cuongquach.com/headless-service-trong-kubernetes-la-gi.html/embed#?secret=Qshyosx2Jm" data-secret="Qshyosx2Jm" frameborder="0" marginwidth="0" marginheight="0" scrolling="no" data-origwidth="600" data-origheight="338" data-mce-fragment="1"></iframe></div></div>
</figure>
<p><a href="https://collabnix.github.io/kubelabs/StatefulSets101/#what-is-statefulset-and-how-is-it-different-from-deployment">https://collabnix.github.io/kubelabs/StatefulSets101/#what-is-statefulset-and-how-is-it-different-from-deployment</a></p>
            ]]>
        </content>
    </entry>
    <entry>
        <title>[Kubernetes] Phần 7: Khái niệm Services</title>
        <author>
            <name>Duong Dinh Trung</name>
        </author>
        <link href="http://blog.dtrungit.ga/kubernetes-phan-7-khai-niem-services/index.html"/>
        <id>http://blog.dtrungit.ga/kubernetes-phan-7-khai-niem-services/index.html</id>
            <category term="Linux"/>
            <category term="K8s"/>

        <updated>2022-06-15T15:26:26+07:00</updated>
            <summary>
                <![CDATA[
                        <img src="http://blog.dtrungit.ga/media/posts/122/k8s.png" alt="" />
                    1. Tổng quan Về mặt lý thuyết, ta có thể expose để người dùng kết nối trực tiếp tới Pod.
                ]]>
            </summary>
        <content type="html">
            <![CDATA[
                    <img src="http://blog.dtrungit.ga/media/posts/122/k8s.png" alt="" />
                <h2>1. Tổng quan</h2>
<p>Về mặt lý thuyết, ta có thể expose để người dùng kết nối trực tiếp tới Pod. Tuy nhiên, Pod trong k8s được tạo mới và tắt đi rất linh hoạt. Mỗi khi 1 pod được tạo mới, chúng sẽ được gắn một địa chỉ riêng. Đồng thời pod tạo K8s có thể được tăng giảm tùy thời điểm (Scale up và Slace down).</p>
<p>Vấn đề:</p>
<ul>
<li>Làm sao để expose được được Pod ra bên ngoài và làm sao người dùng có thể sử dụng dịch vụ?</li>
<li>Làm sao để để Pod chạy dịch vụ <code>frontend</code> có thể kết nối dịch vụ <code>backend</code> (vd: Pod chạy source code WordPress kết nối Pod chạy dịch vụ MariaDB)?</li>
</ul>
<p>Để giải quyết vấn đề trên, K8s sinh ra thành phần Service. Khi Service được sinh ra, nó sẽ được gắn 1 IP chỉ định (còn gọi là clusterIP), IP này sẽ không thay đổi khi cho đên khi Service bị xóa. Qua đó, ta sẽ sử dụng Service để expose service tại tập các Pod. Và Pod có thể nói chuyện trực tiếp với Service trong bài toán <code>Pod frontend service (WordPress)</code> cần kết nối với <code>Pod backend service (MariaDB)</code>.</p>
<p>Tóm tắt:</p>
<ul>
<li>Service có IP chỉ định, đại diện cho tập các Pod thuộc 1 Deployment</li>
<li>Service sẽ tự cân bẳng tải tới tập các Pod</li>
<li>Service có thể định nghĩa bằng file Json hoặc Yaml.</li>
</ul>
<figure class="wp-block-image size-large"><figure class="wp-image-500"><img loading="lazy"  src="https://blog.devopsviet.com/wp-content/uploads/2021/08/pic1-6-1024x528.png" data-is-external-image="true"  sizes="(max-width: 1024px) 100vw, 1024px" srcset="https://blog.devopsviet.com/wp-content/uploads/2021/08/pic1-6-1024x528.png 1024w, https://blog.devopsviet.com/wp-content/uploads/2021/08/pic1-6-300x155.png 300w, https://blog.devopsviet.com/wp-content/uploads/2021/08/pic1-6-768x396.png 768w, https://blog.devopsviet.com/wp-content/uploads/2021/08/pic1-6-816x421.png 816w, https://blog.devopsviet.com/wp-content/uploads/2021/08/pic1-6.png 1407w" alt="" width="1024" height="528" loading="lazy"></figure></figure>
<h2>2. Các loại Service</h2>
<ul>
<li>Có 3 kiểu services:
<ul>
<li>ClusterIP:
<ul>
<li>IP nội bộ K8s đại diện cho diện cho tập các Pod</li>
<li>Traffic tới sẽ được cân bằng tải tới tập các Pod thuộc deployment</li>
</ul>
</li>
<li>Node Port:
<ul>
<li>Sử dụng để expose IP nội bộ bên trong Cluster ra bên ngoài</li>
<li>Mapping 1 cặp <code>IP + Port nội bộ</code> tới cặp 1 cặp <code>IP + Port Bên ngoài</code> để có thể truy cập từ internet vào dịch vụ bên trong Cluster</li>
<li>Traffic được cân bằng tải tới tập các Pod thuộc deployment</li>
</ul>
</li>
<li>LoadBalancer
<ul>
<li>Gắn cho Deployment 1 IP Public</li>
<li>Có thể truy cập dịch vụ thông qua IP Public</li>
<li>Traffic được cân bằng tải tới tập các Pod bên trong Cluster</li>
</ul>
</li>
</ul>
</li>
</ul>
<figure class="wp-block-image size-large"><figure class="wp-image-501"><img loading="lazy"  src="https://blog.devopsviet.com/wp-content/uploads/2021/08/pic2-4-1024x554.png" data-is-external-image="true"  sizes="(max-width: 1024px) 100vw, 1024px" srcset="https://blog.devopsviet.com/wp-content/uploads/2021/08/pic2-4-1024x554.png 1024w, https://blog.devopsviet.com/wp-content/uploads/2021/08/pic2-4-300x162.png 300w, https://blog.devopsviet.com/wp-content/uploads/2021/08/pic2-4-768x416.png 768w, https://blog.devopsviet.com/wp-content/uploads/2021/08/pic2-4-816x442.png 816w, https://blog.devopsviet.com/wp-content/uploads/2021/08/pic2-4.png 1197w" alt="" width="1024" height="554" loading="lazy"></figure></figure>
<h2>3. Mô hình triển khai ứng dụng cơ bản</h2>
<figure class="wp-block-image size-large"><figure class="wp-image-502"><img loading="lazy"  src="https://blog.devopsviet.com/wp-content/uploads/2021/08/pic3-3-1024x566.png" data-is-external-image="true"  sizes="(max-width: 1024px) 100vw, 1024px" srcset="https://blog.devopsviet.com/wp-content/uploads/2021/08/pic3-3-1024x566.png 1024w, https://blog.devopsviet.com/wp-content/uploads/2021/08/pic3-3-300x166.png 300w, https://blog.devopsviet.com/wp-content/uploads/2021/08/pic3-3-768x425.png 768w, https://blog.devopsviet.com/wp-content/uploads/2021/08/pic3-3-816x451.png 816w, https://blog.devopsviet.com/wp-content/uploads/2021/08/pic3-3.png 1354w" alt="" width="1024" height="566" loading="lazy"></figure></figure>
<h2>4. Nguồn</h2>
<p><a href="https://collabnix.github.io/kubelabs/Slides_Services101/Services101.html">https://collabnix.github.io/kubelabs/Slides_Services101/Services101.html</a></p>
<p><a href="https://collabnix.github.io/kubelabs/Services101/#deploying--a-kubernetes-service">https://collabnix.github.io/kubelabs/Services101/#deploying–a-kubernetes-service</a></p>
            ]]>
        </content>
    </entry>
    <entry>
        <title>[Kubernetes] Phần 6: Khái niệm Scheduling</title>
        <author>
            <name>Duong Dinh Trung</name>
        </author>
        <link href="http://blog.dtrungit.ga/kubernetes-phan-6-khai-niem-scheduling/index.html"/>
        <id>http://blog.dtrungit.ga/kubernetes-phan-6-khai-niem-scheduling/index.html</id>
            <category term="Linux"/>
            <category term="K8s"/>

        <updated>2022-06-15T15:25:59+07:00</updated>
            <summary>
                <![CDATA[
                        <img src="http://blog.dtrungit.ga/media/posts/121/k8s.png" alt="" />
                    Tổng quan Kubernetes Scheduler (kube-scheduler) là thành phần core trong k8s. Thành phần này sẽ tính toán để tìm node&hellip;
                ]]>
            </summary>
        <content type="html">
            <![CDATA[
                    <img src="http://blog.dtrungit.ga/media/posts/121/k8s.png" alt="" />
                <h2>Tổng quan</h2>
<p>Kubernetes Scheduler (<code>kube-scheduler</code>) là thành phần core trong k8s. Thành phần này sẽ tính toán để tìm node phù hợp nhất cho Pod, sau đó thông báo <code>kubelet</code> tại Node phù hợp khởi tạo và chạy Pods.</p>
<figure class="wp-block-image size-full"><figure class="wp-image-496"><img loading="lazy"  src="https://blog.devopsviet.com/wp-content/uploads/2021/08/pic1-5.png" data-is-external-image="true"  sizes="(max-width: 768px) 100vw, 768px" srcset="https://blog.devopsviet.com/wp-content/uploads/2021/08/pic1-5.png 768w, https://blog.devopsviet.com/wp-content/uploads/2021/08/pic1-5-300x211.png 300w" alt="" width="768" height="540" loading="lazy"></figure></figure>
<h2>Cách hoạt động</h2>
<p>Kubernetes Scheduler chịu trách nhiệm phân bố Pod tới các Node, luồng hoạt động cơ bản như sau:</p>
<ol>
<li>Người dùng ra lệnh tạo mới Pod</li>
<li><code>kube-scheduler</code> phát hiện có Pod mới được tạo ra nhưng chưa được gắn cho Node</li>
</ol>
<ol start="3">
<li><code>kube-scheduler</code> tìm node phù hợp Pod, sau đó ra lệnh cho <code>kubelet</code> khởi tạo Pod</li>
</ol>
<h2> </h2>
<h2><a href="https://github.com/lacoski/kubernetes-note/blob/main/docs/2.4-scheduler-k8s.md#ngu%E1%BB%93n"></a>Nguồn</h2>
<p><a href="https://kubernetes.io/docs/concepts/scheduling-eviction/kube-scheduler/">https://kubernetes.io/docs/concepts/scheduling-eviction/kube-scheduler/</a></p>
<p><a href="https://collabnix.github.io/kubelabs/Scheduler101/">https://collabnix.github.io/kubelabs/Scheduler101/</a></p>
            ]]>
        </content>
    </entry>
    <entry>
        <title>[Kubernetes] Phần 5: Khái niệm Deployment</title>
        <author>
            <name>Duong Dinh Trung</name>
        </author>
        <link href="http://blog.dtrungit.ga/kubernetes-phan-5-khai-niem-deployment/index.html"/>
        <id>http://blog.dtrungit.ga/kubernetes-phan-5-khai-niem-deployment/index.html</id>
            <category term="Linux"/>
            <category term="K8s"/>

        <updated>2022-06-15T15:25:26+07:00</updated>
            <summary>
                <![CDATA[
                    Tổng quan Với ReplicateSet, ta chỉ có thể tăng giảm số lượng Pod, nhưng vấn để của RS là không&hellip;
                ]]>
            </summary>
        <content type="html">
            <![CDATA[
                <h2>Tổng quan</h2>
<p>Với ReplicateSet, ta chỉ có thể tăng giảm số lượng Pod, nhưng vấn để của RS là không thể thay đổi Pod templates</p>
<p>Ví dụ, ta đang sử dụng ReplicateSet để triển khai 4 pod chạy NodeJS, hiện có yêu cầu thay đổi version NodeJS tới phiên bản mới hơn. Với yêu cầu, ta sẽ phải xóa ReplicateSet cũ và tạo lại ReplicateSet mới. Thao tác này sẽ dẫn đến downtime dịch vụ. Để giải quyết bài toán trên, K8s sử dụng Deployment resource.</p>
<p>Deployment sẽ sử dụng ReplicateSet để quản lý pods, đồng thời nó cũng cho phép cập nhật Pod Template. Ngoài ra, Deployment cũng cung cấp thêm cho người dùng các tính năng như rolling update, roll backs trong bài toán triển khai, cập nhật phiên bản ứng dụng</p>
<figure class="wp-block-image size-full"><figure class="wp-image-464"><img loading="lazy"  src="https://blog.devopsviet.com/wp-content/uploads/2021/08/pic1-4.png" data-is-external-image="true"  sizes="(max-width: 891px) 100vw, 891px" srcset="https://blog.devopsviet.com/wp-content/uploads/2021/08/pic1-4.png 891w, https://blog.devopsviet.com/wp-content/uploads/2021/08/pic1-4-300x208.png 300w, https://blog.devopsviet.com/wp-content/uploads/2021/08/pic1-4-768x534.png 768w, https://blog.devopsviet.com/wp-content/uploads/2021/08/pic1-4-816x567.png 816w" alt="" width="891" height="619" loading="lazy"></figure></figure>
<figure class="wp-block-image size-full"><figure class="wp-image-465"><img loading="lazy"  src="https://blog.devopsviet.com/wp-content/uploads/2021/08/pic2-3.png" data-is-external-image="true"  sizes="(max-width: 709px) 100vw, 709px" srcset="https://blog.devopsviet.com/wp-content/uploads/2021/08/pic2-3.png 709w, https://blog.devopsviet.com/wp-content/uploads/2021/08/pic2-3-267x300.png 267w" alt="" width="709" height="796" loading="lazy"></figure></figure>
<h2>Nguồn</h2>
<p><a href="https://collabnix.github.io/kubelabs/Deployment101/">https://collabnix.github.io/kubelabs/Deployment101/</a></p>
<p><a href="https://github.com/lacoski/kubernetes-note/blob/main/docs/2.3-deployment-k8s.md">https://github.com/lacoski/kubernetes-note/blob/main/docs/2.3-deployment-k8s.md</a></p>
            ]]>
        </content>
    </entry>
    <entry>
        <title>[Kubernetes] Phần 4: Khái niệm ReplicateSet</title>
        <author>
            <name>Duong Dinh Trung</name>
        </author>
        <link href="http://blog.dtrungit.ga/kubernetes-phan-4-khai-niem-replicateset/index.html"/>
        <id>http://blog.dtrungit.ga/kubernetes-phan-4-khai-niem-replicateset/index.html</id>
            <category term="Linux"/>
            <category term="K8s"/>

        <updated>2022-06-15T15:24:59+07:00</updated>
            <summary>
                <![CDATA[
                        <img src="http://blog.dtrungit.ga/media/posts/119/k8s.png" alt="" />
                    Tổng quan ReplicateSet được sử dụng để duy trì một tập replicate các Pod ổn định theo thời gian ReplicateSet&hellip;
                ]]>
            </summary>
        <content type="html">
            <![CDATA[
                    <img src="http://blog.dtrungit.ga/media/posts/119/k8s.png" alt="" />
                <h2>Tổng quan</h2>
<ul>
<li>ReplicateSet được sử dụng để duy trì một tập replicate các Pod ổn định theo thời gian</li>
<li>ReplicateSet quản lý Pod qua các label. Nếu thay đổi label của Pod, ReplicateSet sẽ không quản lý Pod đó nữa</li>
<li>ReplicateSet được sử dụng vì lý do Container hoặc Pod có vòng đời ngắn có thể bị lỗi khi tiến trình container gặp phải exception</li>
<li>Việc sử dụng ReplicateSet sẽ bảo đảm khi có Pod bị ngắt (lỗi) sẽ có Pod khác được tạo ra thay thế</li>
<li>Ngoài ra để Scale số lượng Pod, ta sẽ cấu hình tăng số nhân bản của Pod bằng ReplicateSet</li>
</ul>
<figure class="wp-block-image size-full"><figure class="wp-image-459"><img loading="lazy"  src="https://blog.devopsviet.com/wp-content/uploads/2021/08/pic1-3.png" data-is-external-image="true"  sizes="(max-width: 761px) 100vw, 761px" srcset="https://blog.devopsviet.com/wp-content/uploads/2021/08/pic1-3.png 761w, https://blog.devopsviet.com/wp-content/uploads/2021/08/pic1-3-300x233.png 300w" alt="" width="761" height="592" loading="lazy"></figure></figure>
<h2>Nguồn</h2>
<p><a href="https://github.com/lacoski/kubernetes-note/blob/main/docs/2.2-rs-k8s.md">https://github.com/lacoski/kubernetes-note/blob/main/docs/2.2-rs-k8s.md</a></p>
<p><a href="https://collabnix.github.io/kubelabs/replicaset101/#how-does-replicaset-manage-pods">https://collabnix.github.io/kubelabs/replicaset101/#how-does-replicaset-manage-pods</a></p>
<p><a href="https://collabnix.github.io/kubelabs/SlidesReplicaSet101/ReplicaSet101.html">https://collabnix.github.io/kubelabs/SlidesReplicaSet101/ReplicaSet101.html</a></p>
<p><a href="https://kubernetes.io/docs/concepts/workloads/controllers/replicaset/">https://kubernetes.io/docs/concepts/workloads/controllers/replicaset/</a></p>
            ]]>
        </content>
    </entry>
</feed>
